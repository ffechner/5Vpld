# Overview
This section covers Test Vectors (functional simulation) within CUPL, WinSim and alternate ways of avoiding WinSim. This section is not about timing simulations nor about schematic simulators.
<details>
<summary>Scope: Expand here for details on timing simulations instead</summary>

>There are some possibilities:

>* PLD devices are probably simple enough where the datasheet can be utilized.
>  * Perhaps this might be useful: https://github.com/ezrec/galpal
>* For ATF150x devices see the fitter options, specifically:
>  * <code>-strategy Verilog_sim [sdf | Verilog | OFF]</code>
>  * <code>-strategy Vhdl_sim [sdf | vhdl | OFF]</code>
</details>

<details>
<summary>Scope: Expand here for details on graphical/schematic logic simulators instead</summary>

>[Digital](https://github.com/hneemann/Digital) is an easy-to-use digital logic designer and circuit simulator designed for educational purposes.
>
>See also discussion here: https://github.com/peterzieba/5Vpld/issues/4

>[Digital](https://github.com/hneemann/Digital) is an interesting option as one can create a schematic, view its behavior live on a screen, and then have a .JED file generated for a GAL16V8 or GAL22V10. If one provides the fitters to Digital, it can produce .JED files for the ATF150x series as well. Note that this is more of an educational tool for learning about logic. You may have trouble if you expect fullly featured support of these devices (Tri-state pins, Bi-directional IO, etc.)
>* https://github.com/hneemann/Digital

>If this appeals to you, you might be interested in similar software (though no support for the Atmel parts):
>* <a href="http://www.cburch.com/logisim/">Logisim</a>
>* <a href="https://github.com/logisim-evolution/logisim-evolution">Logisim Evolution</a>
>* <a href="http://visual6502.org/">The Visual 6502</a>

>Finally if what you really want is just schematic entry, consider the Quartus workflow, as it is a modern and fairly powerful tool.

>Other strange (not recommended) but historically notable graphical software that was sometimes bundled with other non-Atmel WinCUPL distributions:
>* There was a piece of software called "Schematic"
>* There was also a piece of software called SMCupl. State Machine Cupl "is a tool used for creating State Diagrams for initial design analysis."
>* Neither of these is likely worth trying to find or use.

</details>

## Using WinSim
The behavior of logic equations to be programmed into a device (or even a virtual device) can be simulated with a utility called WinSim which is part of WinCUPL.

WinSim let you draw a series of waveforms to provide input stimulus to your design, which generates a .SI file (essentially test vectors). CUPL's simulation can then processes your design and the .SI file to generate an .SO file, which WinSim then shows the output waveforms of.

`.SI` file - Simulation/Stimulus Input file. Essentially a text file with test vectors.<br>
`.SO` file - Simulation Output file. Generated by CUPL.EXE if the `-s` compiler option was passed. `5vcomp` automatically adds this option if it detects a `.si` file.

`winsim-preferences.reg` is included to make the interface easier on the eyes (it just changes colors and makes things bigger), but nonetheless, it is has weird problems with not refreshing the screen (at least under Wine???).

# Alternatives approaches to WinSim
Just like WinCUPL, WinSim is an erratic front-end. Thankfully .SI and .SO files are just text files, both of which are very human readable. While WinSim might be quirky, the underlying simulation happens via CUPL.EXE and can be relied upon.

Under the hood, WinSim is just a GUI front-end that allows one to create a <code>.SI</code> file (simulation input) which contains test vectors that are ultimately used by CUPL/CSIM when the `-s` compiler flag is used. The result of the simulation generates an <code>.SO</code> file. WinSim uses both of these files to make an awkward GUI.

## Generating a .SI file without WinSim
Since these are human readable text files, one potential alternative to WinSim is to simply create test vectors in a <code>.SI</code> file and have CUPL/CSIM generate the <code>.SO</code> file for us and view/parse it directly or perhaps convert the .SO into a waveform format useable in another system altogether.

>[!IMPORTANT]
>It is worth mentioning that while legend has it that you can use <code>CSIM.EXE</code> directly, the proper invocation of it seems elusive. What seems to work well instead is passing the <code>-s</code> compiler flag to <code>CUPL.EXE</code>, which then appears to utilize <code>csima.dll</code>.
<details>
<summary>Expand here if you insist on trying to get the CSIM.EXE command-line options to work for you. Again, just use CUPL.EXE with the -s flag for something that works.</summary>
<code>csim [-flags] [library] [device] source
where
-flags is the following set of simulator options:
-l create listing file.
-j append test vectors to JEDEC file.
-n use source filename for JEDEC file.
-v display simulation results to terminal.
-u use specified library for simulation.
library is the library name and path name if the -u flag is being used to specify a
library other than the default library.
device must be the same device mnemonic as was used in the CUPL compilation.
Specifying the device is optional; if a device is not specified, CSIM uses the device
CUPL compiled (contained in the .ABS file).
source is the user-created ASCII test specification file (filename.SI). The
extension .SI is assumed for the source file and may be omitted when giving the
CSIM command.</code>
</details>

The <code>.SI</code> file can be populated with test vectors and be used to simulate the behavior of a particular chip, or even a virtual device. The basic idea of this file is that each column of the VECTORS section represents a single PIN/INPUT/OUTPUT, etc. The characters in this line represent values applied to or tested for on these pins (High, Low, Hi-Z, etc.). Each subsequent line represents another set of values applied to or tested for on these pins. These are applied in sequence starting with the first test vector line and continuing until the end.

Creating a .SI file:<br />
* An .SI file should have the same header information as the original .PLD source file. If not, this will generate warnings.
* It has been noticed that DOS-style newlines are important in this file. Maybe pass it through <code>unix2dos</code> if on Linux.
* An .SI file can have the following keywords/statements: ORDER, BASE, and VECTORS
  * The ORDER keyword (Mandatory) is used to list the variable / inputs and outputs to be used in the simulation table / vector section, and to define how they are displayed. Typically, the variable names are the same as those in the corresponding CUPL logic description file.
  * The BASE keyword specifies a number base. Hexadecimal is the default if unspecified.
  * The VECTORS keyword specifies a list of test vectors (signals that are applied and expected outputs).
* If you simply want to see what will happen on the outputs rather than setting a pre-determined expected value, set the outputs to as asterisk <code>*</code>
* For an explanation of CUPL and JEDEC test vector values, see this [Atmel Application Note: 'Tips on Using Test Vectors for Atmel PLDs'](https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ApplicationNotes/ApplicationNotes/DOC0479.PDF)

<details>
<summary>Expand for a list of valid Test Values used in a test vector</summary>
<code>0 Drive input LO (0 volts) (negate active-HI input)
1 Drive input HI (+5 volts) (assert active-HI input)
C Drive (clock) input LO, HI, LO
K Drive (clock) input HI, LO, HI
L Test output LO (0 volts) (active-HI output negated)
H Test output HI (+5 volts) (active-HI output asserted)
Z Test output for high impedance
X Input HI or LO, output HI or LO Note: Not all device programmers treat X on inputs the same; some put it to 0, some allow input to be pulled to 1, and some leave it at the previous value.
N Output not tested
P Preload internal registers (value is applied to !Q output)
* Outputs only -simulator determines test value and substitutes in vector
' ' Enclose input values to be expanded to a specified BASE (octal, decimal, or hex). Valid values are 0-F and X.
“ ” Enclose output values to be expanded to a specified BASE (octal, decimal, or hex.) Valid values are 0-F, H, L, Z, and X.
</code>
</details>

## Generating a .SI file using an Excel Spreadsheet
This is either a terrible idea, or an excellent idea -- the author has not decided which. The `makesi.py` Python program will accept a `.PLD` file and a `.xlsx` file. The excel file is being used as an alternative to building a GUI interface. Assuming the excel file has been properly formatted, it will print to standard output an `.SI` file. This is a first attempt at this and could probably use some refinement and more documentation/examples.

## JEDEC Test Vectors
Finally, of note is that this functionality isn't strictly for simulation. Test vectors can be appended to a <code>.JED</code> file. Then, if one has an ancient and fancy device programmer which supports these, the idea would be that once a device is programmed by the device programmer, it then runs the test vectors to perform a user-defined test routine on the programmed device. This is useful for a few reasons:
* Correctly reading back and verifying a fusemap from a device is not the same as functionally testing it by setting inputs and reading output pin values in a sequence. Performing both is a more thorough test.
* In situations where the security-fuse is blown (preventing further readout of the fusemap), a test vector can still be used to check a programmed device.

If an <code>.SI</code> file is present and CUPL has the -s and -j options passed to it, it will append the test vectors to the <code>.JED</code> file. This might actually confuse some programmers with poorly implemented `.JED` file parsers. In theory the -j option passed to CSIM.EXE does this as well, but again, this author was unable to get it to run.
